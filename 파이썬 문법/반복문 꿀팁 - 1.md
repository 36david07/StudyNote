# 반복문 꿀팁 - 1

* 파이썬 for문의 이해  
  * 파이썬 이외 언어의 for문
  * 파이썬의 for문
    * range()란?
* enumerate()
* zip()
  * 반복에서
  * 딕셔너리에서
* 순열, 조합, 중복조합, 중복순열 쉽게 쓰기
  * itertools 내장 모듈
  * 제너레이터로 직접 구현

## 글을 읽기 전에...
파이썬의 객체에는, **시퀀스 객체(Sequence Object)** 다른 말로, **시퀀스(Sequence)** 라는 유형의 객체들이 있습니다.  
이 객체들은 **반복가능한 객체**라고도 부르며, 이 글에서는 두 용어를 같이 사용합니다.  
시퀀스 객체의 예시로는, **리스트(list), 튜플(tuple), range, 집합(set), 딕셔너리(dictionary)** 등이 있습니다.  


## 파이썬 for문의 이해  

### 파이썬 이외 언어의 for문
파이썬의 for문은 다른 언어의 for문과 꽤나 차이가 있습니다.  
다른 언어에서는 for문이라고 하면, 우선 for문의 시작과 동시에 선언되는 인덱스(index)를 의미하는 **변수** `i`가 있고,  
이 `i`를 정해진 **변화식**, 보통은 `i++`만큼 변화시키면서,   
정해진 **조건식**, 보통은 `i < n`을 만족하는 한 계속 반복합니다.  
```c++
// C++ 코드 예시
#include <iostream>
using namespace std;

int main(){
    int n = 10;
    for (i=0;i<n;i++){
        cout << 'HelloWorld';
        // 10회 반복해서 HelloWorld 출력
    }
    
    /*
    for (변수;조건식;변화식){
        조건식;
    }
    대부분의 언어는 이런 식으로 반복을 한다.
    */
}
```
### 파이썬의 for문

파이썬의 for문은 변수를 선언하는 부분까지는 다른 언어의 for문과 비슷하지만, 조건식과 변화식이 없습니다.  
```python
for i in range(10):
    print('HelloWorld')
    # 10회 반복해서 HelloWorld 출력
    # 조건식(i<10)은 다른 방식으로 표현되었고, 변화식(i++)은 없음
    # -> range()와 파이썬 for문 문법이 만든 결과
```

파이썬의 for문은 다른 언어의 for문과 아예 다른 문법이라고 생각하셔도 됩니다.  
각자 for문으로 더 편하게 수행할 수 있는 기능이 다르고, 만든 이의 철학(?)이 근본부터 다르기 때문입니다.

```python
# 다음의 반복문들이 '차이가 없다'는 것을 이해하셔야 합니다!

for c in "abcd":
  print(c, end=' ')
  # a b c d가 출력됨
  # (반복가능한) 문자열 객체 "abcd"의 원소들을 하나씩 꺼내면서 반복

for i in range(10):
  print(i, end=' ')
  # 0 1 2 3 4 5 6 7 8 9가 출력됨
  # (반복가능한) range 객체 range(10)의 원소들을 하나씩 꺼내면서 반복

for x in [0, 'a', 1.2, False]:
  print(x, end=' ')
  # 0 a 1.2 False가 출력됨
  # (반복가능한) 리스트 객체 [0, 'a', 1.2, False]의 원소들을 하나씩 꺼내면서 반복

for x in {1, 2, 3, 4}:
  print(x, end=' ')
  # 1 2 3 4가 무작위 순서로 출력됨
  # (반복가능한) 집합 객체 set(1, 2, 3, 4)의 원소들을 하나씩 꺼내면서 반복
```

위 코드에서 보셨듯이, 파이썬의 for문은 **조건식**이나, **변화식**같은 개념으로 해석하기보다는,  
더 적절한 개념으로, **반복가능한 객체(시퀀스 객체)에서 하나씩 원소를 꺼내면서 반복**한다는 개념으로 이해하시는 게 좋습니다.  
따라서, 반복 변수도 C++처럼 새로 창조해서 _선언_한다는 개념보다도,   
하나씩 원소를 꺼낼 때에 그 원소를 뭐라고 부를지? 이름, 별명을 붙여주는 개념에 가깝습니다.    

#### range란?

`range()`는 리스트, 튜플, 딕셔너리, 집합 등의 우리가 흔히 아는 시퀀스 객체와는 또 다른,  
독자적인 시퀀스 객체입니다. (실제로 range라는 객체가 존재. 리스트가 아님)  
```python
print(type(range(10))) # <class 'range'>
print(range(10)) # range(0, 10)
```
`range(start, end, step)`으로 `range()`객체를 만들면, 정수로 이루어진 반복가능한 객체가 하나 만들어집니다.  
어차피 반복문에 넣고 돌리면, 리스트에서 하나씩 꺼내 쓰든, `range()`에서 하나씩 꺼내 쓰든,  
서로 같기 때문에 편의를 위해서 `range()`를 써왔던 것이라고 생각하시면 됩니다.  
```python
# 만약 반복문에 쓰이는 시퀀스 객체도 저장하고 싶다면
arr = list(range(10))
for i in arr:
    print(i)
    # 이런 식으로 리스트로 따로 만들어서 저장해주어야 한다
    # 리스트로 안바꾸고 range를 바로 저장하면 어떻게 되는지는 위에서 이미 소개함
```
`range()`는 `list()`가 아니기 때문에, 리스트 내장함수 `예:sort()` 등은 쓸 수 없지만, 슬라이싱 문법은 사용할 수 있습니다.  
이때 슬라이싱해서 나온 객체 또한 range입니다.  
```python
print(range(10)) # range(0, 10)
print(range(10)[1:7:2]) # range(1, 7, 2)
print(range(1, 7, 2)) # range(1, 7, 2)
```
`range()`의 step 기능을 이용한다면 물론 더 간결하고, 빠르게 표현할 수 있는 것은 맞습니다.  
하지만, 긴 코드가 전체적으로 슬라이싱을 활용하여 작성되어있다던가, range의 step보단 슬라이싱의 step이 더 친숙하다던가 등의 이유가 있기에,  
range의 step기능보다는 슬라이싱을 활용하는 편이 코드를 더 간결하게 쓸 수 있습니다. (개인적인 생각)

## enumerate()

`enumerate(sequence)`는 enumerate 타입의 객체를 생성하는 문법입니다.  
원본의 sequence와, 그 인덱스로 이루어진 새로운 enumerate 타입의 객체를 생성합니다.  
주로 반복문에서 `enumerate()`를 사용하는데, 시퀀스 객체의 원소 값 하나 하나도 필요하고, 그 인덱스도 같이 필요할 때에 사용합니다.  
`enumerate()`는 시간복잡도도 낮기에, 잘 활용하면 간결하고 좋은 코드를 짤 수 있습니다.(사람들이 잘 몰라서 간지나기도 합니다!)  
```python
# enumerate 기본 활용

word = 'Hello Python!'
for i, x in enumerate(word): # 반드시!!! (인덱스, 원소) 꼴로 써줘야 한다!
    print(f'{i}번째 원소는 {x}입니다.')
    # 0번째 원소는 H입니다.
    # 1번째 원소는 e입니다.
    # ...
```

```python
# enumerate 안쓰고 코드 짜기
word = 'Hello Python!'
for i in range(len(word)): # len()의 시간복잡도가 O(N)이어서, enumerate와 효율이 같다.
    x = word[i]
    print(f'{i}번째 원소는 {x}입니다.')
    # 0번째 원소는 H입니다.
    # 1번째 원소는 e입니다.
    # ...
```

## zip()

zip() 역시 list(), range(), enumerate()와 같은, 파이썬의 시퀀스 객체 중에 하나입니다.