# 리스트 슬라이싱(List Slicing)

* 슬라이싱 안 헷갈리게 사용하기
* step은 왜 쓰는 걸까?
* 리스트의 복사
* 슬라이싱의 시간, 공간복잡도
* 언패킹 문법 최대로 활용하기
* 문자열 뒤집기
* 2차원 리스트 슬라이싱 방법

## 슬라이싱 안 헷갈리게 사용하기
슬라이싱은 기본적으로 `seq[start:end:step]`으로 사용합니다.  
배열의 인덱스를 `i`라 할 때, `start <= i < end`가 슬라이싱의 범위입니다.   
이때, 슬라이싱의 크기는 항상 `end-start`입니다.  

`seq[::]`처럼 start, end, step을 각각 생략할 때엔, 기본값으로 `seq[0:len(seq):1]`이 들어갑니다.  
파이썬의 음수 인덱스 기능을 사용해서, `seq[i:-1]`처럼 쓰면 `i~끝`을 지정하는 것처럼 보이지만, 그렇지 않습니다.  
만약 뒤쪽 끝을 지정하고싶다면 그냥 `seq[i:]`처럼 생략하는 것이 훨씬 실수를 줄이는 방법입니다.  


`step`이 음수가 되어서 슬라이싱이 뒤집어질 경우에는 검색을 해서 문법을 알아보는 것이 더 편합니다.

## step은 왜 쓰는 걸까?
`step`이 포함된 슬라이싱 코드는 자동으로 범위를 잘 지정해서 `Index Error`을 방지해줍니다.  
예를 들어서, 0~10까지 수가 담긴 리스트 `a = list(range(11))`가 있을 때,  
3의 배수 번째 index에 대한 리스트를 만들어야 하는 경우를 생각해봅시다.   
가장 정석적인 while문을 쓰는 코드를 짜본다면, 다음과 같습니다.
```
a = list(range(11)) # a = [0, 1, 2, ..., 9, 10]
i = 0
sliced = []
while i < len(a):
    sliced.append(a[i])
    i += 3 
    # while문이 돌면서 i는 0, 3, 6, 9가 되고, 12가 되면서 종료.
```
다른 프로그래밍 언어에서도 주로 쓰이는 이런 코드는 while문을 사용하다보니 종료 조건을 꼼꼼히 따져주어야 합니다.   
`len(a)`가 3의 배수면? 3의 배수가 아니면? 어떤 `Index Error`가 발생할지, 직접 고쳐주어야 합니다.   
파이썬에선 이걸 step과 슬라이싱으로 더 쉽게 해결할 수 있습니다.
```
a = list(range(11))
sliced = a[::3] # 슬라이싱이 자동으로 인덱스 에러가 안나게끔 잘라줌
```
이 방법은 `a[::-4]`처럼 음수 step에도 사용 가능하기에, `len(a)`가 1000을 넘어가는 빅데이터를 처리할 때에 매우 편리합니다.

## 리스트의 복사