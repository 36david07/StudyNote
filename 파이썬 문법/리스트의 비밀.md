# 리스트의 비밀

* 파이썬의 리스트 특징
* 리스트 내부구조 - 다양한 자료형 저장
* 리스트 내부구조 - 유연한 메모리 할당
* 리스트 특징으로 인한 현상들

## 파이썬의 리스트 특징

파이썬은 리스트(list)라는, 다른 여러 언어의 배열보다 훨씬 더 많고 좋은 기능을 제공하는 자료형이 있습니다.  
일반적으로 다른 언어에서 배열은 최소한 길이가 정해져있고, 안에 넣을 수 있는 자료형이 정해져있는 경우가 많습니다.  
C++의 경우를 예시로 들어보겠습니다.
```
#include <iostream>

int main()
{
    int prime[5]; 
    prime[0] = 2;
    prime[1] = 3; 
    prime[2] = 5;
    prime[3] = 7;
    prime[4] = 11;
    
    // int형 5개만큼의 공간만을 할당받음
    // 배열의 크기를 늘리거나, 축소하지 못함 (일반적인 경우)
    // 배열 안에 들어가는 형이 고정적임
    
    // 파이썬의 리스트처럼 사용 가능한 기능이 많지 않음
    
    return 0;
}
```
이런 식으로 다른 언어에서는 배열의 사용처가 한정적입니다.  
그래서 C++에서는 헤더파일로, 배열 이외에 다른 여러 자료구조를 가져와 사용합니다.  

파이썬의 리스트는 이런 불편함을 감수하지 않아도 되고, 사용가능한 기능도 더 다양합니다.
```
# 파이썬의 리스트는 다양한 조작이 가능

a = [1, 2, 3]

a.append(4) 
# a = [1, 2, 3, 4]

a.pop(0) 
# a = [2, 3, 4]

a = a[::-2] 
# a = [4, 2]

a.sort() 
# a = [2, 4]

a.append('Hello') 
# a = [2, 4, 'Hello']

a.append(a)
# a = [2, 4, 'Hello', [...]]
# 말도 안되는 것 같아 보이지만 실제로 된다.
# a[3]과 a는 완전히 같은 객체이다. (a = a[3] = a[3][3] = ...)
```

## 리스트 내부구조 - 다양한 자료형 저장

파이썬의 리스트는 어떻게 만들었길래 다른 언어에서는 안되는 복잡한 기능들을 마구 쓸 수 있는 걸까요?  
그건 파이썬이 리스트에 원소를 저장하는 방식고 관련이 있습니다.  
C++나 다른 언어들에서는 일반적으로 배열에 원소를 추가할 때엔, 배열의 주소값에 (index)*(자료형의 메모리 크기)를 더한 값을 원소의 주소로 사용합니다.  
```
// C++의 배열 주소 예시

int a[3]; # 주소: 20
a[0] = 1; # 24
a[1] = 2; # 28
a[2] = 3; # 32

# 배열 객체 a자체의 주소를 20이라고 했을 때
# int 자료형은 4byte이므로, 원소들은 4*index씩 뒤로 밀린 인덱스를 가짐
```

파이썬의 리스트는 자료형을 구분하지 않고 받아들이기에, 이런 방식은 사용할 수 없습니다.  
그래서, 파이썬은 리스트에 실제 원소의 값이 아닌, 원소의 주소값을 저장하는 방식을 사용합니다.  
예를 들면, `'asdf'`를 저장하는 경우에 실제 str 자료형의 값 `asdf`를 저장하는 것이 아닌,  
`asdf`의 주소인 `140573474786352 (항상 같은 게 아님!)`같은 수를 저장하는 것입니다.  

예시입니다.
```
A = [1, 'a', None, [1, 2]] # 값을 저장한 것처럼 보이지만

B = [4489910976, 140563006159152, 
     4448722576, 140394965131968] # 실제론 주소를 저장한 것이다!
     
# 참고: A와 B가 같은 리스트라는 게 아님. 단지 예시일 뿐임
```

이런 저장방식으로 인해서 리스트는 여러 자료형을 저장할 수 있습니다.  
정수, 실수, 문자열, 배열, 함수, 클래스의 인스턴스 등등 전부 '**주소**'를 갖기 때문이죠.  
이러한 방식은 리스트가 필요로 하는 메모리를 2배, 혹은 그 이상으로 늘리지만,  
다양한 자료형을 저장하고 다양한 연산을 지원하게 된다는 메리트가 있기에 편리합니다.

## 리스트 내부구조 - 유연한 메모리 할당

리스트는 어떻게 자동으로 유연하게 메모리를 할당받는 걸까요?  

리스트가 생성될때, 리스트는 기본적으로 26byte 정도의 메모리를 할당받습니다.  
만약 최초에 할당받은 메모리로는 충분하지 않을 정도로 더 많은 값을 저장해야 할 경우엔,  
파이썬의 내부 동작을 담당하는 C언어에서 리스트에 **2배**의 메모리를 할당해줍니다. 
2배를 할당했는데도 부족하면, 4배, 8배, ... 점점 할당하는 배수를 높이며   
내 컴퓨터가 사용할 수 있는 메모리를 전부 끌어와서 리스트에 메모리를 추가로 할당합니다.  

리스트에 메모리를 동적으로 추가 할당하는 과정에서 과도하게 동적**으로만** 할당하려고 하면,  
쓸데없이 동적 메모리를 많이 차지하게 되지만, 사실 요즘 컴퓨터로는 별로 상관쓰지 않아도 되는 부분입니다.

```
a = [] # 26 byte 정도의 메모리의 리스트 생성

for i in range(100000):
    a.append(i) # a에 할당된 메모리를 2배씩 늘려가며 확장

# 위의 코드보다는 아래의 코드가 훨씬 안정적이고 메모리 적게 소모

a = [0]*100000 # int형을 10만개 정도 쓰겠다고 미리 초기화
# 메모리를 추가 할당할 때의 배수가 2배 고정이 아닌, 4배, 8배, ... 
# 으로 늘려가며 빠르게 메모리를 늘려놓고, 고정함

for i in range(100000):
    a[i] = i 
    # 반복문을 돌면서 동적 메모리는 하나도 안 건듬
```

만약 `pop()`등의 연산으로 메모리가 줄어들 일이 생겼다면,  
파이썬이 자동으로 적절하게 사용하지 않는 만큼의 메모리를 할당 해제합니다.
메모리를 줄이는 부분은 별로 중요하지 않습니다.  

## 리스트 특징으로 인한 현상들

리스트의 내부 구조 특징을 정리해보자면, 다음과 같습니다.
* 리스트는 값 자체를 저장하지 않고 값의 주소를 저장한다.
* 리스트는 처음엔 메모리가 고정되어있다가, 변해야 할 때만 변한다.

여기서 이런 특징으로 인해 발생하는 여러 경우를 살펴봅시다.  

1. n by m 행렬을 만들고 싶을 때 다음의 두 방법이 어떤 차이가 있을까?
```
A = [[0]*m]*n # X
B = [[0]*m for _ in range(n)] # O
```
두번째 방법은 잘 작동하지만, 첫번째 방법은 외부의 리스트가 `[0]*m`이라는 리스트를 `n개` 저장하는 것이 아닌,  
`1개`만 만들어놓고 그 주소까지 싹 같은 리스트를 `n개` 저장하는 것이기 때문에 우리의 생각대로 작동하지 않는 것입니다.
```
address = 32618 # 이게 [0]*m의 주소라고 하면 
B = [32618,32618,32618,...,32618] # n개 있는 것
```
주소가 달라야지 내부의 원소가 바뀌면 바뀐 내용이 한 내부리스트에만 되기에 원하는 대로 작동하지 않는 것이다. 
이는 행렬같은 2차원 리스트에만 해당되는 내용이 아니라, 모든 반복 가능한 객체(시퀀스) 안에 반복 가능한 객체 꼴에 전부 적용되는 내용ㅇ